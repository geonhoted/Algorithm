# -*- coding: utf-8 -*-
"""알고리즘_학기말과제

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1YzuyOd9Yw1rE7n3LhS6O2Z8WCliIjzpR
"""

#P01

#조합 라이브러리 불러오기
from itertools import combinations

#Input값 받고 분리시켜서 청년/비청년 다른 리스트에 각각 저장
youth = input().split()
non_youth = input().split()
K = int(input())

#필요한 리스트들 정의
num_y = len(youth)
num_n = len(non_youth)
y_list = list()
n_list = list()
pass_list = list()
result = list()
last = list()

#맨 처음 for문은 K값에 따라 청년/비청년 리스트에 할당되는 수치의 경우의수를 고려한 것
#청년의 인원 수를 점점 증가시키다가 비청년 최소인원수를 초과해버리면 중단
for i in range(1, 1+K-3+1):
  if (i > K-2):
    break
  #앞서 각각 할당한 인원 수에 맞게 가능한 청년/비청년 각각의 조합 경우의 수를 리스트에 저장
  for y in combinations(youth, i):
    y_list.append(y)
  for n in combinations(non_youth, K-i):
    n_list.append(n)
  #각 리스트의 조합 경우의 수를 합쳐서 최종 조합 경우를 모두 하나의 리스트에 저장
  #문제의 조건에 맞게 알파벳 순서로 정렬하고 최종 출력을 위해 모든 경우를 출력용 리스트에 저장
  for j in range(0, len(y_list)):
    for k in range(0, len(n_list)):
      pass_list = ((y_list[j])) + ((n_list[k]))
      pass_list = sorted(pass_list)
      result.append(pass_list)
      pass_list = []
  y_list = []
  n_list = []

#정렬된 각각의 원소를 띄어쓰기를 하며 하나의 문자열로 저장
for j in range(0, len(result)):
  sum = ' '.join(result[j])
  last.append(sum)
  last = sorted(last)

#모든 문자열을 출력
for i in range(0, len(last)):
  print(last[i])

#P02

N = int(input())

C = []
C.append(1)
new_C = 0

for i in range(0,N):
  for j in range(0, i+1):
    new_C = new_C + C[j]*C[-(1+j)]
  C.append(new_C)
  new_C = 0

f = 1
for i in range(1,N+1):
  f = f * i

result = f - C[-1]

print(result)

#P03

#출전한 모든 조합을 기록할 리스트 선언
Char = []

#END 나오기 전까지 모든 INPUT값 리스트에 넣음
while(True):
  a = input()
  if a == 'END':
    break
  else:
    Char.append(a.split())

#한 번이라도 등장했던 캐릭터를 중복없이 하나의 리스트에 새로 저장
total = []
for i in range(0, len(Char)):
  for j in range(0, len(Char[i])):
    if Char[i][j] not in total:
      total.append(Char[i][j])

#두 캐릭터의 조합이 등장한 빈도를 기록할 2차원 리스트 선언, 16개 원소에 0값 부여
#예시코드의 경우 총 4종류의 캐릭터가 등장하는데 편의를 위해 4x4행렬로 선언
num = []
for i in range(0, len(total)):
  new_list = []
  for j in range(0, len(total)):
    new_list.append(0)
  num.append(new_list)

#Char을 전부 탐색하여 가능한한 모든 조합을 구성하고 해당 조합이 나온 횟수를 num에 기록함.
#이때 j의 인덱스가 i+1에서 시작하므로 4x4행렬을 했더라고 중복될일은 발생하지 않음.
for k in range(0, len(Char)):
  for i in range(0, len(total)-1):
    if total[i] in Char[k]:
      for j in range(i+1, len(total)):
        if total[j] in Char[k]:
          num[i][j] += 1

#같은 두개의 캐릭터가 계산된 경우를 빼려고 넣었는데 생각해보니 필요없음.
for i in range(0, len(total)):
  num[i][i] = 0

#베스트 조합은 몇 번 등장했는지 찾기 위해 num의 원소 중 제일 큰 값을 찾기 위해 전수조사함.
compare = []
for i in range(0, len(total)):
  for j in range(0, len(total)):
    compare.append(num[i][j])


#전수조사한 값들 중 max값을 가진 조합이 몇 개인지 count
ans = (compare.count(max(compare)))

#과정확인용
print(Char)
print(total)
print(num)

#진짜답
print(ans)

#P03

#출전한 모든 조합을 기록할 리스트 선언
Char = []

#END 나오기 전까지 모든 INPUT값 리스트에 넣음
while(True):
  a = input()
  if a == 'END':
    break
  else:
    Char.append(a.split())

#한 번이라도 등장했던 캐릭터를 중복없이 하나의 리스트에 새로 저장
total = []
for i in range(0, len(Char)):
  for j in range(0, len(Char[i])):
    if Char[i][j] not in total:
      total.append(Char[i][j])

best = []
best_index = []

from itertools import combination

for c in combinations(total, 2):
  best.append(c)
  for y in Char:
    check = True
    count = 0
    for x in best:
      for z in x:
        if z not in y:
          check = False
      if check == True:
        count += 1
        best_index.append(count)

#P03

#출전한 모든 조합을 기록할 리스트 선언
Char = []

#END 나오기 전까지 모든 INPUT값 리스트에 넣음
while(True):
  a = input()
  if a == 'END':
    break
  else:
    Char.append(a.split())

#한 번이라도 등장했던 캐릭터를 중복없이 하나의 리스트에 새로 저장
total = []
for i in range(0, len(Char)):
  for j in range(0, len(Char[i])):
    if Char[i][j] not in total:
      total.append(Char[i][j])

print(total)

result = 0
from itertools import combinations

for i in range(2, len(total)+1):
  best = []
  for c in combinations(total, i):
    best.append(list(c))
  for y in Char:
    count = 0
    for x in best:
      check = True
      for z in x:
        if z not in y:
          check = False
          break
      if check == True:
        count += 1
      if count > len(Char)//2:
        result += 1
        break

print(result)

#입력값
#Teemo Vayne
#Vayne Yummi Teemo
#Yasuo Yummi Vayne
#END

x = ['a', 'b','d']
y = ['a', 'b', 'c']

for i in y:
  check = True
  for j in x:
    if j not in y:
      check = False

print(check)

#P03

#출전한 모든 조합을 기록할 리스트 선언
Char = []

#END 나오기 전까지 모든 INPUT값 리스트에 넣음
while(True):
  a = input()
  if a == 'END':
    break
  else:
    Char.append(a.split())

#한 번이라도 등장했던 캐릭터를 중복없이 하나의 리스트에 새로 저장
total = []
for i in range(0, len(Char)):
  for j in range(0, len(Char[i])):
    if Char[i][j] not in total:
      total.append(Char[i][j])

print(total)

result = 0
from itertools import combinations

for i in range(2, len(total)+1):
  for c in combinations(total, i):
    count = 0
    for y in Char:
        if all(z in y for z in c):
            count += 1
    if count > len(Char)//2:
      result += 1

print(result)

